// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include "FileSystemWorkerClientService.h"
#include "FileSystemWorkerClientServiceHandler.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

FileSystemWorkerClientServiceHandler::FileSystemWorkerClientServiceHandler()

  {
    // Your initialization goes here
	  printf("cout goes here\n");
  }

  int64_t FileSystemWorkerClientServiceHandler::getServiceVersion()
  	  {
	  return 114;
  	  }
  /**
   * Cancels a file which has not been completed in the under file system.
   * 
   * @param sessionId the id of the current session
   * 
   * @param tempUfsFileId the worker specific file id of the ufs file
   * 
   * @param options the options for canceling the file
   */
  void FileSystemWorkerClientServiceHandler::cancelUfsFile(const int64_t sessionId, const int64_t tempUfsFileId, const CancelUfsFileTOptions& options) {
    // Your implementation goes here
    printf("cancelUfsFile\n");
  }

  /**
   * Closes a file in the under file system which was previously opened for reading.
   * 
   * 
   * @param sessionId the id of the current session
   * 
   * @param tempUfsFileId the worker specific file id of the ufs file
   * 
   * @param options the options for closing the file
   */
  void FileSystemWorkerClientServiceHandler::closeUfsFile(const int64_t sessionId, const int64_t tempUfsFileId, const CloseUfsFileTOptions& options) {
    // Your implementation goes here
    printf("closeUfsFile\n");
  }

  /**
   * Completes a file in the under file system.
   * 
   * @param sessionId the id of the current session
   * 
   * @param tempUfsFileId the worker specific file id of the ufs file
   * 
   * @param options the options for completing the file
   */
  int64_t FileSystemWorkerClientServiceHandler::completeUfsFile(const int64_t sessionId, const int64_t tempUfsFileId, const CompleteUfsFileTOptions& options) {
    // Your implementation goes here
    printf("completeUfsFile\n");
    return(-1);
  }

  /**
   * Creates a file in the under file system.
   * 
   * @param sessionId the id of the current session
   * 
   * @param ufsPath the path of the file in the ufs
   * 
   * @param options the options for creating the file
   */
  int64_t FileSystemWorkerClientServiceHandler::createUfsFile(const int64_t sessionId, const std::string& ufsPath, const CreateUfsFileTOptions& options) {
    // Your implementation goes here
    printf("createUfsFile\n");
    return(-1);
  }

  /**
   * Opens an existing file in the under file system for reading.
   * 
   * @param sessionId the id of the current session
   * 
   * @param ufsPath the path of the file in the ufs
   * 
   * @param options the options for opening the file
   */
  int64_t FileSystemWorkerClientServiceHandler::openUfsFile(const int64_t sessionId, const std::string& ufsPath, const OpenUfsFileTOptions& options) {
    // Your implementation goes here
    printf("openUfsFile\n");
    return(-1);
  }

  /**
   * Local session send heartbeat to local worker to keep its state.
   * 
   * @param sessionId the id of the current session
   * 
   * @param metrics the client metrics. deprecated since 1.3.0 and will be removed in 2.0
   */
  void FileSystemWorkerClientServiceHandler::sessionHeartbeat(const int64_t sessionId, const std::vector<int64_t> & metrics) {
    // Your implementation goes here
    printf("sessionHeartbeat\n");
  }


//int main(int argc, char **argv) {
//  int port = 9090;
//  shared_ptr<FileSystemWorkerClientServiceHandler> handler(new FileSystemWorkerClientServiceHandler());
//  shared_ptr<TProcessor> processor(new FileSystemWorkerClientServiceProcessor(handler));
//  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
//  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
//  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
//
//  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
//  server.serve();
//  return 0;
//}

