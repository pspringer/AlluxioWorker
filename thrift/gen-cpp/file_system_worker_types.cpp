/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "file_system_worker_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>




CancelUfsFileTOptions::~CancelUfsFileTOptions() throw() {
}


uint32_t CancelUfsFileTOptions::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CancelUfsFileTOptions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CancelUfsFileTOptions");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CancelUfsFileTOptions &a, CancelUfsFileTOptions &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CancelUfsFileTOptions::CancelUfsFileTOptions(const CancelUfsFileTOptions& other0) {
  (void) other0;
}
CancelUfsFileTOptions& CancelUfsFileTOptions::operator=(const CancelUfsFileTOptions& other1) {
  (void) other1;
  return *this;
}
void CancelUfsFileTOptions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CancelUfsFileTOptions(";
  out << ")";
}


CloseUfsFileTOptions::~CloseUfsFileTOptions() throw() {
}


uint32_t CloseUfsFileTOptions::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CloseUfsFileTOptions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CloseUfsFileTOptions");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CloseUfsFileTOptions &a, CloseUfsFileTOptions &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CloseUfsFileTOptions::CloseUfsFileTOptions(const CloseUfsFileTOptions& other2) {
  (void) other2;
}
CloseUfsFileTOptions& CloseUfsFileTOptions::operator=(const CloseUfsFileTOptions& other3) {
  (void) other3;
  return *this;
}
void CloseUfsFileTOptions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CloseUfsFileTOptions(";
  out << ")";
}


CompleteUfsFileTOptions::~CompleteUfsFileTOptions() throw() {
}


void CompleteUfsFileTOptions::__set_owner(const std::string& val) {
  this->owner = val;
__isset.owner = true;
}

void CompleteUfsFileTOptions::__set_group(const std::string& val) {
  this->group = val;
__isset.group = true;
}

void CompleteUfsFileTOptions::__set_mode(const int16_t val) {
  this->mode = val;
__isset.mode = true;
}

uint32_t CompleteUfsFileTOptions::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->owner);
          this->__isset.owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->group);
          this->__isset.group = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->mode);
          this->__isset.mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CompleteUfsFileTOptions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CompleteUfsFileTOptions");

  if (this->__isset.owner) {
    xfer += oprot->writeFieldBegin("owner", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->owner);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.group) {
    xfer += oprot->writeFieldBegin("group", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->group);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mode) {
    xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_I16, 3);
    xfer += oprot->writeI16(this->mode);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CompleteUfsFileTOptions &a, CompleteUfsFileTOptions &b) {
  using ::std::swap;
  swap(a.owner, b.owner);
  swap(a.group, b.group);
  swap(a.mode, b.mode);
  swap(a.__isset, b.__isset);
}

CompleteUfsFileTOptions::CompleteUfsFileTOptions(const CompleteUfsFileTOptions& other4) {
  owner = other4.owner;
  group = other4.group;
  mode = other4.mode;
  __isset = other4.__isset;
}
CompleteUfsFileTOptions& CompleteUfsFileTOptions::operator=(const CompleteUfsFileTOptions& other5) {
  owner = other5.owner;
  group = other5.group;
  mode = other5.mode;
  __isset = other5.__isset;
  return *this;
}
void CompleteUfsFileTOptions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CompleteUfsFileTOptions(";
  out << "owner="; (__isset.owner ? (out << to_string(owner)) : (out << "<null>"));
  out << ", " << "group="; (__isset.group ? (out << to_string(group)) : (out << "<null>"));
  out << ", " << "mode="; (__isset.mode ? (out << to_string(mode)) : (out << "<null>"));
  out << ")";
}


CreateUfsFileTOptions::~CreateUfsFileTOptions() throw() {
}


void CreateUfsFileTOptions::__set_owner(const std::string& val) {
  this->owner = val;
__isset.owner = true;
}

void CreateUfsFileTOptions::__set_group(const std::string& val) {
  this->group = val;
__isset.group = true;
}

void CreateUfsFileTOptions::__set_mode(const int16_t val) {
  this->mode = val;
__isset.mode = true;
}

uint32_t CreateUfsFileTOptions::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->owner);
          this->__isset.owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->group);
          this->__isset.group = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->mode);
          this->__isset.mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CreateUfsFileTOptions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreateUfsFileTOptions");

  if (this->__isset.owner) {
    xfer += oprot->writeFieldBegin("owner", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->owner);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.group) {
    xfer += oprot->writeFieldBegin("group", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->group);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mode) {
    xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_I16, 3);
    xfer += oprot->writeI16(this->mode);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreateUfsFileTOptions &a, CreateUfsFileTOptions &b) {
  using ::std::swap;
  swap(a.owner, b.owner);
  swap(a.group, b.group);
  swap(a.mode, b.mode);
  swap(a.__isset, b.__isset);
}

CreateUfsFileTOptions::CreateUfsFileTOptions(const CreateUfsFileTOptions& other6) {
  owner = other6.owner;
  group = other6.group;
  mode = other6.mode;
  __isset = other6.__isset;
}
CreateUfsFileTOptions& CreateUfsFileTOptions::operator=(const CreateUfsFileTOptions& other7) {
  owner = other7.owner;
  group = other7.group;
  mode = other7.mode;
  __isset = other7.__isset;
  return *this;
}
void CreateUfsFileTOptions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreateUfsFileTOptions(";
  out << "owner="; (__isset.owner ? (out << to_string(owner)) : (out << "<null>"));
  out << ", " << "group="; (__isset.group ? (out << to_string(group)) : (out << "<null>"));
  out << ", " << "mode="; (__isset.mode ? (out << to_string(mode)) : (out << "<null>"));
  out << ")";
}


OpenUfsFileTOptions::~OpenUfsFileTOptions() throw() {
}


uint32_t OpenUfsFileTOptions::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OpenUfsFileTOptions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OpenUfsFileTOptions");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OpenUfsFileTOptions &a, OpenUfsFileTOptions &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

OpenUfsFileTOptions::OpenUfsFileTOptions(const OpenUfsFileTOptions& other8) {
  (void) other8;
}
OpenUfsFileTOptions& OpenUfsFileTOptions::operator=(const OpenUfsFileTOptions& other9) {
  (void) other9;
  return *this;
}
void OpenUfsFileTOptions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OpenUfsFileTOptions(";
  out << ")";
}


