/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "BlockMasterWorkerService.h"




BlockMasterWorkerService_commitBlock_args::~BlockMasterWorkerService_commitBlock_args() throw() {
}


uint32_t BlockMasterWorkerService_commitBlock_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->workerId);
          this->__isset.workerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->usedBytesOnTier);
          this->__isset.usedBytesOnTier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tierAlias);
          this->__isset.tierAlias = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->blockId);
          this->__isset.blockId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->length);
          this->__isset.length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BlockMasterWorkerService_commitBlock_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BlockMasterWorkerService_commitBlock_args");

  xfer += oprot->writeFieldBegin("workerId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->workerId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("usedBytesOnTier", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->usedBytesOnTier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tierAlias", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tierAlias);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("blockId", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->blockId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("length", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->length);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


BlockMasterWorkerService_commitBlock_pargs::~BlockMasterWorkerService_commitBlock_pargs() throw() {
}


uint32_t BlockMasterWorkerService_commitBlock_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BlockMasterWorkerService_commitBlock_pargs");

  xfer += oprot->writeFieldBegin("workerId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->workerId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("usedBytesOnTier", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->usedBytesOnTier)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tierAlias", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->tierAlias)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("blockId", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64((*(this->blockId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("length", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64((*(this->length)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


BlockMasterWorkerService_commitBlock_result::~BlockMasterWorkerService_commitBlock_result() throw() {
}


uint32_t BlockMasterWorkerService_commitBlock_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->e.read(iprot);
          this->__isset.e = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BlockMasterWorkerService_commitBlock_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("BlockMasterWorkerService_commitBlock_result");

  if (this->__isset.e) {
    xfer += oprot->writeFieldBegin("e", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->e.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


BlockMasterWorkerService_commitBlock_presult::~BlockMasterWorkerService_commitBlock_presult() throw() {
}


uint32_t BlockMasterWorkerService_commitBlock_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->e.read(iprot);
          this->__isset.e = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


BlockMasterWorkerService_getWorkerId_args::~BlockMasterWorkerService_getWorkerId_args() throw() {
}


uint32_t BlockMasterWorkerService_getWorkerId_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->workerNetAddress.read(iprot);
          this->__isset.workerNetAddress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BlockMasterWorkerService_getWorkerId_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BlockMasterWorkerService_getWorkerId_args");

  xfer += oprot->writeFieldBegin("workerNetAddress", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->workerNetAddress.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


BlockMasterWorkerService_getWorkerId_pargs::~BlockMasterWorkerService_getWorkerId_pargs() throw() {
}


uint32_t BlockMasterWorkerService_getWorkerId_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BlockMasterWorkerService_getWorkerId_pargs");

  xfer += oprot->writeFieldBegin("workerNetAddress", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->workerNetAddress)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


BlockMasterWorkerService_getWorkerId_result::~BlockMasterWorkerService_getWorkerId_result() throw() {
}


uint32_t BlockMasterWorkerService_getWorkerId_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->e.read(iprot);
          this->__isset.e = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BlockMasterWorkerService_getWorkerId_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("BlockMasterWorkerService_getWorkerId_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.e) {
    xfer += oprot->writeFieldBegin("e", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->e.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


BlockMasterWorkerService_getWorkerId_presult::~BlockMasterWorkerService_getWorkerId_presult() throw() {
}


uint32_t BlockMasterWorkerService_getWorkerId_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->e.read(iprot);
          this->__isset.e = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


BlockMasterWorkerService_heartbeat_args::~BlockMasterWorkerService_heartbeat_args() throw() {
}


uint32_t BlockMasterWorkerService_heartbeat_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->workerId);
          this->__isset.workerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->usedBytesOnTiers.clear();
            uint32_t _size13;
            ::apache::thrift::protocol::TType _ktype14;
            ::apache::thrift::protocol::TType _vtype15;
            xfer += iprot->readMapBegin(_ktype14, _vtype15, _size13);
            uint32_t _i17;
            for (_i17 = 0; _i17 < _size13; ++_i17)
            {
              std::string _key18;
              xfer += iprot->readString(_key18);
              int64_t& _val19 = this->usedBytesOnTiers[_key18];
              xfer += iprot->readI64(_val19);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.usedBytesOnTiers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->removedBlockIds.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _etype23;
            xfer += iprot->readListBegin(_etype23, _size20);
            this->removedBlockIds.resize(_size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              xfer += iprot->readI64(this->removedBlockIds[_i24]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.removedBlockIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->addedBlocksOnTiers.clear();
            uint32_t _size25;
            ::apache::thrift::protocol::TType _ktype26;
            ::apache::thrift::protocol::TType _vtype27;
            xfer += iprot->readMapBegin(_ktype26, _vtype27, _size25);
            uint32_t _i29;
            for (_i29 = 0; _i29 < _size25; ++_i29)
            {
              std::string _key30;
              xfer += iprot->readString(_key30);
              std::vector<int64_t> & _val31 = this->addedBlocksOnTiers[_key30];
              {
                _val31.clear();
                uint32_t _size32;
                ::apache::thrift::protocol::TType _etype35;
                xfer += iprot->readListBegin(_etype35, _size32);
                _val31.resize(_size32);
                uint32_t _i36;
                for (_i36 = 0; _i36 < _size32; ++_i36)
                {
                  xfer += iprot->readI64(_val31[_i36]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.addedBlocksOnTiers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BlockMasterWorkerService_heartbeat_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BlockMasterWorkerService_heartbeat_args");

  xfer += oprot->writeFieldBegin("workerId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->workerId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("usedBytesOnTiers", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->usedBytesOnTiers.size()));
    std::map<std::string, int64_t> ::const_iterator _iter37;
    for (_iter37 = this->usedBytesOnTiers.begin(); _iter37 != this->usedBytesOnTiers.end(); ++_iter37)
    {
      xfer += oprot->writeString(_iter37->first);
      xfer += oprot->writeI64(_iter37->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("removedBlockIds", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->removedBlockIds.size()));
    std::vector<int64_t> ::const_iterator _iter38;
    for (_iter38 = this->removedBlockIds.begin(); _iter38 != this->removedBlockIds.end(); ++_iter38)
    {
      xfer += oprot->writeI64((*_iter38));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addedBlocksOnTiers", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->addedBlocksOnTiers.size()));
    std::map<std::string, std::vector<int64_t> > ::const_iterator _iter39;
    for (_iter39 = this->addedBlocksOnTiers.begin(); _iter39 != this->addedBlocksOnTiers.end(); ++_iter39)
    {
      xfer += oprot->writeString(_iter39->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(_iter39->second.size()));
        std::vector<int64_t> ::const_iterator _iter40;
        for (_iter40 = _iter39->second.begin(); _iter40 != _iter39->second.end(); ++_iter40)
        {
          xfer += oprot->writeI64((*_iter40));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


BlockMasterWorkerService_heartbeat_pargs::~BlockMasterWorkerService_heartbeat_pargs() throw() {
}


uint32_t BlockMasterWorkerService_heartbeat_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BlockMasterWorkerService_heartbeat_pargs");

  xfer += oprot->writeFieldBegin("workerId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->workerId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("usedBytesOnTiers", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->usedBytesOnTiers)).size()));
    std::map<std::string, int64_t> ::const_iterator _iter41;
    for (_iter41 = (*(this->usedBytesOnTiers)).begin(); _iter41 != (*(this->usedBytesOnTiers)).end(); ++_iter41)
    {
      xfer += oprot->writeString(_iter41->first);
      xfer += oprot->writeI64(_iter41->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("removedBlockIds", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->removedBlockIds)).size()));
    std::vector<int64_t> ::const_iterator _iter42;
    for (_iter42 = (*(this->removedBlockIds)).begin(); _iter42 != (*(this->removedBlockIds)).end(); ++_iter42)
    {
      xfer += oprot->writeI64((*_iter42));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addedBlocksOnTiers", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>((*(this->addedBlocksOnTiers)).size()));
    std::map<std::string, std::vector<int64_t> > ::const_iterator _iter43;
    for (_iter43 = (*(this->addedBlocksOnTiers)).begin(); _iter43 != (*(this->addedBlocksOnTiers)).end(); ++_iter43)
    {
      xfer += oprot->writeString(_iter43->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(_iter43->second.size()));
        std::vector<int64_t> ::const_iterator _iter44;
        for (_iter44 = _iter43->second.begin(); _iter44 != _iter43->second.end(); ++_iter44)
        {
          xfer += oprot->writeI64((*_iter44));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


BlockMasterWorkerService_heartbeat_result::~BlockMasterWorkerService_heartbeat_result() throw() {
}


uint32_t BlockMasterWorkerService_heartbeat_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->e.read(iprot);
          this->__isset.e = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BlockMasterWorkerService_heartbeat_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("BlockMasterWorkerService_heartbeat_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.e) {
    xfer += oprot->writeFieldBegin("e", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->e.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


BlockMasterWorkerService_heartbeat_presult::~BlockMasterWorkerService_heartbeat_presult() throw() {
}


uint32_t BlockMasterWorkerService_heartbeat_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->e.read(iprot);
          this->__isset.e = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


BlockMasterWorkerService_registerWorker_args::~BlockMasterWorkerService_registerWorker_args() throw() {
}


uint32_t BlockMasterWorkerService_registerWorker_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->workerId);
          this->__isset.workerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->storageTiers.clear();
            uint32_t _size45;
            ::apache::thrift::protocol::TType _etype48;
            xfer += iprot->readListBegin(_etype48, _size45);
            this->storageTiers.resize(_size45);
            uint32_t _i49;
            for (_i49 = 0; _i49 < _size45; ++_i49)
            {
              xfer += iprot->readString(this->storageTiers[_i49]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.storageTiers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->totalBytesOnTiers.clear();
            uint32_t _size50;
            ::apache::thrift::protocol::TType _ktype51;
            ::apache::thrift::protocol::TType _vtype52;
            xfer += iprot->readMapBegin(_ktype51, _vtype52, _size50);
            uint32_t _i54;
            for (_i54 = 0; _i54 < _size50; ++_i54)
            {
              std::string _key55;
              xfer += iprot->readString(_key55);
              int64_t& _val56 = this->totalBytesOnTiers[_key55];
              xfer += iprot->readI64(_val56);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.totalBytesOnTiers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->usedBytesOnTiers.clear();
            uint32_t _size57;
            ::apache::thrift::protocol::TType _ktype58;
            ::apache::thrift::protocol::TType _vtype59;
            xfer += iprot->readMapBegin(_ktype58, _vtype59, _size57);
            uint32_t _i61;
            for (_i61 = 0; _i61 < _size57; ++_i61)
            {
              std::string _key62;
              xfer += iprot->readString(_key62);
              int64_t& _val63 = this->usedBytesOnTiers[_key62];
              xfer += iprot->readI64(_val63);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.usedBytesOnTiers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->currentBlocksOnTiers.clear();
            uint32_t _size64;
            ::apache::thrift::protocol::TType _ktype65;
            ::apache::thrift::protocol::TType _vtype66;
            xfer += iprot->readMapBegin(_ktype65, _vtype66, _size64);
            uint32_t _i68;
            for (_i68 = 0; _i68 < _size64; ++_i68)
            {
              std::string _key69;
              xfer += iprot->readString(_key69);
              std::vector<int64_t> & _val70 = this->currentBlocksOnTiers[_key69];
              {
                _val70.clear();
                uint32_t _size71;
                ::apache::thrift::protocol::TType _etype74;
                xfer += iprot->readListBegin(_etype74, _size71);
                _val70.resize(_size71);
                uint32_t _i75;
                for (_i75 = 0; _i75 < _size71; ++_i75)
                {
                  xfer += iprot->readI64(_val70[_i75]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.currentBlocksOnTiers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BlockMasterWorkerService_registerWorker_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BlockMasterWorkerService_registerWorker_args");

  xfer += oprot->writeFieldBegin("workerId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->workerId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("storageTiers", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->storageTiers.size()));
    std::vector<std::string> ::const_iterator _iter76;
    for (_iter76 = this->storageTiers.begin(); _iter76 != this->storageTiers.end(); ++_iter76)
    {
      xfer += oprot->writeString((*_iter76));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("totalBytesOnTiers", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->totalBytesOnTiers.size()));
    std::map<std::string, int64_t> ::const_iterator _iter77;
    for (_iter77 = this->totalBytesOnTiers.begin(); _iter77 != this->totalBytesOnTiers.end(); ++_iter77)
    {
      xfer += oprot->writeString(_iter77->first);
      xfer += oprot->writeI64(_iter77->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("usedBytesOnTiers", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->usedBytesOnTiers.size()));
    std::map<std::string, int64_t> ::const_iterator _iter78;
    for (_iter78 = this->usedBytesOnTiers.begin(); _iter78 != this->usedBytesOnTiers.end(); ++_iter78)
    {
      xfer += oprot->writeString(_iter78->first);
      xfer += oprot->writeI64(_iter78->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("currentBlocksOnTiers", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->currentBlocksOnTiers.size()));
    std::map<std::string, std::vector<int64_t> > ::const_iterator _iter79;
    for (_iter79 = this->currentBlocksOnTiers.begin(); _iter79 != this->currentBlocksOnTiers.end(); ++_iter79)
    {
      xfer += oprot->writeString(_iter79->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(_iter79->second.size()));
        std::vector<int64_t> ::const_iterator _iter80;
        for (_iter80 = _iter79->second.begin(); _iter80 != _iter79->second.end(); ++_iter80)
        {
          xfer += oprot->writeI64((*_iter80));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


BlockMasterWorkerService_registerWorker_pargs::~BlockMasterWorkerService_registerWorker_pargs() throw() {
}


uint32_t BlockMasterWorkerService_registerWorker_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BlockMasterWorkerService_registerWorker_pargs");

  xfer += oprot->writeFieldBegin("workerId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->workerId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("storageTiers", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->storageTiers)).size()));
    std::vector<std::string> ::const_iterator _iter81;
    for (_iter81 = (*(this->storageTiers)).begin(); _iter81 != (*(this->storageTiers)).end(); ++_iter81)
    {
      xfer += oprot->writeString((*_iter81));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("totalBytesOnTiers", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->totalBytesOnTiers)).size()));
    std::map<std::string, int64_t> ::const_iterator _iter82;
    for (_iter82 = (*(this->totalBytesOnTiers)).begin(); _iter82 != (*(this->totalBytesOnTiers)).end(); ++_iter82)
    {
      xfer += oprot->writeString(_iter82->first);
      xfer += oprot->writeI64(_iter82->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("usedBytesOnTiers", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*(this->usedBytesOnTiers)).size()));
    std::map<std::string, int64_t> ::const_iterator _iter83;
    for (_iter83 = (*(this->usedBytesOnTiers)).begin(); _iter83 != (*(this->usedBytesOnTiers)).end(); ++_iter83)
    {
      xfer += oprot->writeString(_iter83->first);
      xfer += oprot->writeI64(_iter83->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("currentBlocksOnTiers", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>((*(this->currentBlocksOnTiers)).size()));
    std::map<std::string, std::vector<int64_t> > ::const_iterator _iter84;
    for (_iter84 = (*(this->currentBlocksOnTiers)).begin(); _iter84 != (*(this->currentBlocksOnTiers)).end(); ++_iter84)
    {
      xfer += oprot->writeString(_iter84->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(_iter84->second.size()));
        std::vector<int64_t> ::const_iterator _iter85;
        for (_iter85 = _iter84->second.begin(); _iter85 != _iter84->second.end(); ++_iter85)
        {
          xfer += oprot->writeI64((*_iter85));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


BlockMasterWorkerService_registerWorker_result::~BlockMasterWorkerService_registerWorker_result() throw() {
}


uint32_t BlockMasterWorkerService_registerWorker_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->e.read(iprot);
          this->__isset.e = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BlockMasterWorkerService_registerWorker_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("BlockMasterWorkerService_registerWorker_result");

  if (this->__isset.e) {
    xfer += oprot->writeFieldBegin("e", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->e.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


BlockMasterWorkerService_registerWorker_presult::~BlockMasterWorkerService_registerWorker_presult() throw() {
}


uint32_t BlockMasterWorkerService_registerWorker_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->e.read(iprot);
          this->__isset.e = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void BlockMasterWorkerServiceClient::commitBlock(const int64_t workerId, const int64_t usedBytesOnTier, const std::string& tierAlias, const int64_t blockId, const int64_t length)
{
  send_commitBlock(workerId, usedBytesOnTier, tierAlias, blockId, length);
  recv_commitBlock();
}

void BlockMasterWorkerServiceClient::send_commitBlock(const int64_t workerId, const int64_t usedBytesOnTier, const std::string& tierAlias, const int64_t blockId, const int64_t length)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commitBlock", ::apache::thrift::protocol::T_CALL, cseqid);

  BlockMasterWorkerService_commitBlock_pargs args;
  args.workerId = &workerId;
  args.usedBytesOnTier = &usedBytesOnTier;
  args.tierAlias = &tierAlias;
  args.blockId = &blockId;
  args.length = &length;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void BlockMasterWorkerServiceClient::recv_commitBlock()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commitBlock") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  BlockMasterWorkerService_commitBlock_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.e) {
    throw result.e;
  }
  return;
}

int64_t BlockMasterWorkerServiceClient::getWorkerId(const  ::WorkerNetAddress& workerNetAddress)
{
  send_getWorkerId(workerNetAddress);
  return recv_getWorkerId();
}

void BlockMasterWorkerServiceClient::send_getWorkerId(const  ::WorkerNetAddress& workerNetAddress)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getWorkerId", ::apache::thrift::protocol::T_CALL, cseqid);

  BlockMasterWorkerService_getWorkerId_pargs args;
  args.workerNetAddress = &workerNetAddress;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int64_t BlockMasterWorkerServiceClient::recv_getWorkerId()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getWorkerId") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int64_t _return;
  BlockMasterWorkerService_getWorkerId_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.e) {
    throw result.e;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getWorkerId failed: unknown result");
}

void BlockMasterWorkerServiceClient::heartbeat( ::Command& _return, const int64_t workerId, const std::map<std::string, int64_t> & usedBytesOnTiers, const std::vector<int64_t> & removedBlockIds, const std::map<std::string, std::vector<int64_t> > & addedBlocksOnTiers)
{
  send_heartbeat(workerId, usedBytesOnTiers, removedBlockIds, addedBlocksOnTiers);
  recv_heartbeat(_return);
}

void BlockMasterWorkerServiceClient::send_heartbeat(const int64_t workerId, const std::map<std::string, int64_t> & usedBytesOnTiers, const std::vector<int64_t> & removedBlockIds, const std::map<std::string, std::vector<int64_t> > & addedBlocksOnTiers)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("heartbeat", ::apache::thrift::protocol::T_CALL, cseqid);

  BlockMasterWorkerService_heartbeat_pargs args;
  args.workerId = &workerId;
  args.usedBytesOnTiers = &usedBytesOnTiers;
  args.removedBlockIds = &removedBlockIds;
  args.addedBlocksOnTiers = &addedBlocksOnTiers;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void BlockMasterWorkerServiceClient::recv_heartbeat( ::Command& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("heartbeat") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  BlockMasterWorkerService_heartbeat_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.e) {
    throw result.e;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "heartbeat failed: unknown result");
}

void BlockMasterWorkerServiceClient::registerWorker(const int64_t workerId, const std::vector<std::string> & storageTiers, const std::map<std::string, int64_t> & totalBytesOnTiers, const std::map<std::string, int64_t> & usedBytesOnTiers, const std::map<std::string, std::vector<int64_t> > & currentBlocksOnTiers)
{
  send_registerWorker(workerId, storageTiers, totalBytesOnTiers, usedBytesOnTiers, currentBlocksOnTiers);
  recv_registerWorker();
}

void BlockMasterWorkerServiceClient::send_registerWorker(const int64_t workerId, const std::vector<std::string> & storageTiers, const std::map<std::string, int64_t> & totalBytesOnTiers, const std::map<std::string, int64_t> & usedBytesOnTiers, const std::map<std::string, std::vector<int64_t> > & currentBlocksOnTiers)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("registerWorker", ::apache::thrift::protocol::T_CALL, cseqid);

  BlockMasterWorkerService_registerWorker_pargs args;
  args.workerId = &workerId;
  args.storageTiers = &storageTiers;
  args.totalBytesOnTiers = &totalBytesOnTiers;
  args.usedBytesOnTiers = &usedBytesOnTiers;
  args.currentBlocksOnTiers = &currentBlocksOnTiers;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void BlockMasterWorkerServiceClient::recv_registerWorker()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("registerWorker") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  BlockMasterWorkerService_registerWorker_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.e) {
    throw result.e;
  }
  return;
}

bool BlockMasterWorkerServiceProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    return  ::AlluxioServiceProcessor::dispatchCall(iprot, oprot, fname, seqid, callContext);
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void BlockMasterWorkerServiceProcessor::process_commitBlock(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("BlockMasterWorkerService.commitBlock", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "BlockMasterWorkerService.commitBlock");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "BlockMasterWorkerService.commitBlock");
  }

  BlockMasterWorkerService_commitBlock_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "BlockMasterWorkerService.commitBlock", bytes);
  }

  BlockMasterWorkerService_commitBlock_result result;
  try {
    iface_->commitBlock(args.workerId, args.usedBytesOnTier, args.tierAlias, args.blockId, args.length);
  } catch ( ::AlluxioTException &e) {
    result.e = e;
    result.__isset.e = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "BlockMasterWorkerService.commitBlock");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commitBlock", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "BlockMasterWorkerService.commitBlock");
  }

  oprot->writeMessageBegin("commitBlock", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "BlockMasterWorkerService.commitBlock", bytes);
  }
}

void BlockMasterWorkerServiceProcessor::process_getWorkerId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("BlockMasterWorkerService.getWorkerId", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "BlockMasterWorkerService.getWorkerId");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "BlockMasterWorkerService.getWorkerId");
  }

  BlockMasterWorkerService_getWorkerId_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "BlockMasterWorkerService.getWorkerId", bytes);
  }

  BlockMasterWorkerService_getWorkerId_result result;
  try {
    result.success = iface_->getWorkerId(args.workerNetAddress);
    result.__isset.success = true;
  } catch ( ::AlluxioTException &e) {
    result.e = e;
    result.__isset.e = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "BlockMasterWorkerService.getWorkerId");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getWorkerId", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "BlockMasterWorkerService.getWorkerId");
  }

  oprot->writeMessageBegin("getWorkerId", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "BlockMasterWorkerService.getWorkerId", bytes);
  }
}

void BlockMasterWorkerServiceProcessor::process_heartbeat(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("BlockMasterWorkerService.heartbeat", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "BlockMasterWorkerService.heartbeat");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "BlockMasterWorkerService.heartbeat");
  }

  BlockMasterWorkerService_heartbeat_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "BlockMasterWorkerService.heartbeat", bytes);
  }

  BlockMasterWorkerService_heartbeat_result result;
  try {
    iface_->heartbeat(result.success, args.workerId, args.usedBytesOnTiers, args.removedBlockIds, args.addedBlocksOnTiers);
    result.__isset.success = true;
  } catch ( ::AlluxioTException &e) {
    result.e = e;
    result.__isset.e = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "BlockMasterWorkerService.heartbeat");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("heartbeat", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "BlockMasterWorkerService.heartbeat");
  }

  oprot->writeMessageBegin("heartbeat", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "BlockMasterWorkerService.heartbeat", bytes);
  }
}

void BlockMasterWorkerServiceProcessor::process_registerWorker(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("BlockMasterWorkerService.registerWorker", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "BlockMasterWorkerService.registerWorker");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "BlockMasterWorkerService.registerWorker");
  }

  BlockMasterWorkerService_registerWorker_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "BlockMasterWorkerService.registerWorker", bytes);
  }

  BlockMasterWorkerService_registerWorker_result result;
  try {
    iface_->registerWorker(args.workerId, args.storageTiers, args.totalBytesOnTiers, args.usedBytesOnTiers, args.currentBlocksOnTiers);
  } catch ( ::AlluxioTException &e) {
    result.e = e;
    result.__isset.e = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "BlockMasterWorkerService.registerWorker");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("registerWorker", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "BlockMasterWorkerService.registerWorker");
  }

  oprot->writeMessageBegin("registerWorker", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "BlockMasterWorkerService.registerWorker", bytes);
  }
}

::boost::shared_ptr< ::apache::thrift::TProcessor > BlockMasterWorkerServiceProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< BlockMasterWorkerServiceIfFactory > cleanup(handlerFactory_);
  ::boost::shared_ptr< BlockMasterWorkerServiceIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::boost::shared_ptr< ::apache::thrift::TProcessor > processor(new BlockMasterWorkerServiceProcessor(handler));
  return processor;
}

void BlockMasterWorkerServiceConcurrentClient::commitBlock(const int64_t workerId, const int64_t usedBytesOnTier, const std::string& tierAlias, const int64_t blockId, const int64_t length)
{
  int32_t seqid = send_commitBlock(workerId, usedBytesOnTier, tierAlias, blockId, length);
  recv_commitBlock(seqid);
}

int32_t BlockMasterWorkerServiceConcurrentClient::send_commitBlock(const int64_t workerId, const int64_t usedBytesOnTier, const std::string& tierAlias, const int64_t blockId, const int64_t length)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("commitBlock", ::apache::thrift::protocol::T_CALL, cseqid);

  BlockMasterWorkerService_commitBlock_pargs args;
  args.workerId = &workerId;
  args.usedBytesOnTier = &usedBytesOnTier;
  args.tierAlias = &tierAlias;
  args.blockId = &blockId;
  args.length = &length;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void BlockMasterWorkerServiceConcurrentClient::recv_commitBlock(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("commitBlock") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      BlockMasterWorkerService_commitBlock_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.e) {
        sentry.commit();
        throw result.e;
      }
      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int64_t BlockMasterWorkerServiceConcurrentClient::getWorkerId(const  ::WorkerNetAddress& workerNetAddress)
{
  int32_t seqid = send_getWorkerId(workerNetAddress);
  return recv_getWorkerId(seqid);
}

int32_t BlockMasterWorkerServiceConcurrentClient::send_getWorkerId(const  ::WorkerNetAddress& workerNetAddress)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getWorkerId", ::apache::thrift::protocol::T_CALL, cseqid);

  BlockMasterWorkerService_getWorkerId_pargs args;
  args.workerNetAddress = &workerNetAddress;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int64_t BlockMasterWorkerServiceConcurrentClient::recv_getWorkerId(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getWorkerId") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int64_t _return;
      BlockMasterWorkerService_getWorkerId_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.e) {
        sentry.commit();
        throw result.e;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getWorkerId failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void BlockMasterWorkerServiceConcurrentClient::heartbeat( ::Command& _return, const int64_t workerId, const std::map<std::string, int64_t> & usedBytesOnTiers, const std::vector<int64_t> & removedBlockIds, const std::map<std::string, std::vector<int64_t> > & addedBlocksOnTiers)
{
  int32_t seqid = send_heartbeat(workerId, usedBytesOnTiers, removedBlockIds, addedBlocksOnTiers);
  recv_heartbeat(_return, seqid);
}

int32_t BlockMasterWorkerServiceConcurrentClient::send_heartbeat(const int64_t workerId, const std::map<std::string, int64_t> & usedBytesOnTiers, const std::vector<int64_t> & removedBlockIds, const std::map<std::string, std::vector<int64_t> > & addedBlocksOnTiers)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("heartbeat", ::apache::thrift::protocol::T_CALL, cseqid);

  BlockMasterWorkerService_heartbeat_pargs args;
  args.workerId = &workerId;
  args.usedBytesOnTiers = &usedBytesOnTiers;
  args.removedBlockIds = &removedBlockIds;
  args.addedBlocksOnTiers = &addedBlocksOnTiers;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void BlockMasterWorkerServiceConcurrentClient::recv_heartbeat( ::Command& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("heartbeat") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      BlockMasterWorkerService_heartbeat_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.e) {
        sentry.commit();
        throw result.e;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "heartbeat failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void BlockMasterWorkerServiceConcurrentClient::registerWorker(const int64_t workerId, const std::vector<std::string> & storageTiers, const std::map<std::string, int64_t> & totalBytesOnTiers, const std::map<std::string, int64_t> & usedBytesOnTiers, const std::map<std::string, std::vector<int64_t> > & currentBlocksOnTiers)
{
  int32_t seqid = send_registerWorker(workerId, storageTiers, totalBytesOnTiers, usedBytesOnTiers, currentBlocksOnTiers);
  recv_registerWorker(seqid);
}

int32_t BlockMasterWorkerServiceConcurrentClient::send_registerWorker(const int64_t workerId, const std::vector<std::string> & storageTiers, const std::map<std::string, int64_t> & totalBytesOnTiers, const std::map<std::string, int64_t> & usedBytesOnTiers, const std::map<std::string, std::vector<int64_t> > & currentBlocksOnTiers)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("registerWorker", ::apache::thrift::protocol::T_CALL, cseqid);

  BlockMasterWorkerService_registerWorker_pargs args;
  args.workerId = &workerId;
  args.storageTiers = &storageTiers;
  args.totalBytesOnTiers = &totalBytesOnTiers;
  args.usedBytesOnTiers = &usedBytesOnTiers;
  args.currentBlocksOnTiers = &currentBlocksOnTiers;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void BlockMasterWorkerServiceConcurrentClient::recv_registerWorker(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("registerWorker") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      BlockMasterWorkerService_registerWorker_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.e) {
        sentry.commit();
        throw result.e;
      }
      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}



