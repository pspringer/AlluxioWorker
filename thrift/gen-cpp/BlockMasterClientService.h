/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef BlockMasterClientService_H
#define BlockMasterClientService_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include "block_master_types.h"
#include "AlluxioService.h"



#ifdef _WIN32
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

class BlockMasterClientServiceIf : virtual public  ::AlluxioServiceIf {
 public:
  virtual ~BlockMasterClientServiceIf() {}

  /**
   * Returns the block information for the given block id.
   * 
   * @param blockId the id of the block
   */
  virtual void getBlockInfo( ::BlockInfo& _return, const int64_t blockId) = 0;

  /**
   * Returns the capacity (in bytes).
   */
  virtual int64_t getCapacityBytes() = 0;

  /**
   * Returns the used storage (in bytes).
   */
  virtual int64_t getUsedBytes() = 0;

  /**
   * Returns a list of workers information.
   */
  virtual void getWorkerInfoList(std::vector<WorkerInfo> & _return) = 0;
};

class BlockMasterClientServiceIfFactory : virtual public  ::AlluxioServiceIfFactory {
 public:
  typedef BlockMasterClientServiceIf Handler;

  virtual ~BlockMasterClientServiceIfFactory() {}

  virtual BlockMasterClientServiceIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler( ::AlluxioServiceIf* /* handler */) = 0;
};

class BlockMasterClientServiceIfSingletonFactory : virtual public BlockMasterClientServiceIfFactory {
 public:
  BlockMasterClientServiceIfSingletonFactory(const boost::shared_ptr<BlockMasterClientServiceIf>& iface) : iface_(iface) {}
  virtual ~BlockMasterClientServiceIfSingletonFactory() {}

  virtual BlockMasterClientServiceIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler( ::AlluxioServiceIf* /* handler */) {}

 protected:
  boost::shared_ptr<BlockMasterClientServiceIf> iface_;
};

class BlockMasterClientServiceNull : virtual public BlockMasterClientServiceIf , virtual public  ::AlluxioServiceNull {
 public:
  virtual ~BlockMasterClientServiceNull() {}
  void getBlockInfo( ::BlockInfo& /* _return */, const int64_t /* blockId */) {
    return;
  }
  int64_t getCapacityBytes() {
    int64_t _return = 0;
    return _return;
  }
  int64_t getUsedBytes() {
    int64_t _return = 0;
    return _return;
  }
  void getWorkerInfoList(std::vector<WorkerInfo> & /* _return */) {
    return;
  }
};

typedef struct _BlockMasterClientService_getBlockInfo_args__isset {
  _BlockMasterClientService_getBlockInfo_args__isset() : blockId(false) {}
  bool blockId :1;
} _BlockMasterClientService_getBlockInfo_args__isset;

class BlockMasterClientService_getBlockInfo_args {
 public:

  BlockMasterClientService_getBlockInfo_args(const BlockMasterClientService_getBlockInfo_args&);
  BlockMasterClientService_getBlockInfo_args& operator=(const BlockMasterClientService_getBlockInfo_args&);
  BlockMasterClientService_getBlockInfo_args() : blockId(0) {
  }

  virtual ~BlockMasterClientService_getBlockInfo_args() throw();
  int64_t blockId;

  _BlockMasterClientService_getBlockInfo_args__isset __isset;

  void __set_blockId(const int64_t val);

  bool operator == (const BlockMasterClientService_getBlockInfo_args & rhs) const
  {
    if (!(blockId == rhs.blockId))
      return false;
    return true;
  }
  bool operator != (const BlockMasterClientService_getBlockInfo_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BlockMasterClientService_getBlockInfo_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BlockMasterClientService_getBlockInfo_pargs {
 public:


  virtual ~BlockMasterClientService_getBlockInfo_pargs() throw();
  const int64_t* blockId;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _BlockMasterClientService_getBlockInfo_result__isset {
  _BlockMasterClientService_getBlockInfo_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _BlockMasterClientService_getBlockInfo_result__isset;

class BlockMasterClientService_getBlockInfo_result {
 public:

  BlockMasterClientService_getBlockInfo_result(const BlockMasterClientService_getBlockInfo_result&);
  BlockMasterClientService_getBlockInfo_result& operator=(const BlockMasterClientService_getBlockInfo_result&);
  BlockMasterClientService_getBlockInfo_result() {
  }

  virtual ~BlockMasterClientService_getBlockInfo_result() throw();
   ::BlockInfo success;
   ::AlluxioTException e;

  _BlockMasterClientService_getBlockInfo_result__isset __isset;

  void __set_success(const  ::BlockInfo& val);

  void __set_e(const  ::AlluxioTException& val);

  bool operator == (const BlockMasterClientService_getBlockInfo_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const BlockMasterClientService_getBlockInfo_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BlockMasterClientService_getBlockInfo_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _BlockMasterClientService_getBlockInfo_presult__isset {
  _BlockMasterClientService_getBlockInfo_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _BlockMasterClientService_getBlockInfo_presult__isset;

class BlockMasterClientService_getBlockInfo_presult {
 public:


  virtual ~BlockMasterClientService_getBlockInfo_presult() throw();
   ::BlockInfo* success;
   ::AlluxioTException e;

  _BlockMasterClientService_getBlockInfo_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class BlockMasterClientService_getCapacityBytes_args {
 public:

  BlockMasterClientService_getCapacityBytes_args(const BlockMasterClientService_getCapacityBytes_args&);
  BlockMasterClientService_getCapacityBytes_args& operator=(const BlockMasterClientService_getCapacityBytes_args&);
  BlockMasterClientService_getCapacityBytes_args() {
  }

  virtual ~BlockMasterClientService_getCapacityBytes_args() throw();

  bool operator == (const BlockMasterClientService_getCapacityBytes_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const BlockMasterClientService_getCapacityBytes_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BlockMasterClientService_getCapacityBytes_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BlockMasterClientService_getCapacityBytes_pargs {
 public:


  virtual ~BlockMasterClientService_getCapacityBytes_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _BlockMasterClientService_getCapacityBytes_result__isset {
  _BlockMasterClientService_getCapacityBytes_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _BlockMasterClientService_getCapacityBytes_result__isset;

class BlockMasterClientService_getCapacityBytes_result {
 public:

  BlockMasterClientService_getCapacityBytes_result(const BlockMasterClientService_getCapacityBytes_result&);
  BlockMasterClientService_getCapacityBytes_result& operator=(const BlockMasterClientService_getCapacityBytes_result&);
  BlockMasterClientService_getCapacityBytes_result() : success(0) {
  }

  virtual ~BlockMasterClientService_getCapacityBytes_result() throw();
  int64_t success;
   ::AlluxioTException e;

  _BlockMasterClientService_getCapacityBytes_result__isset __isset;

  void __set_success(const int64_t val);

  void __set_e(const  ::AlluxioTException& val);

  bool operator == (const BlockMasterClientService_getCapacityBytes_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const BlockMasterClientService_getCapacityBytes_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BlockMasterClientService_getCapacityBytes_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _BlockMasterClientService_getCapacityBytes_presult__isset {
  _BlockMasterClientService_getCapacityBytes_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _BlockMasterClientService_getCapacityBytes_presult__isset;

class BlockMasterClientService_getCapacityBytes_presult {
 public:


  virtual ~BlockMasterClientService_getCapacityBytes_presult() throw();
  int64_t* success;
   ::AlluxioTException e;

  _BlockMasterClientService_getCapacityBytes_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class BlockMasterClientService_getUsedBytes_args {
 public:

  BlockMasterClientService_getUsedBytes_args(const BlockMasterClientService_getUsedBytes_args&);
  BlockMasterClientService_getUsedBytes_args& operator=(const BlockMasterClientService_getUsedBytes_args&);
  BlockMasterClientService_getUsedBytes_args() {
  }

  virtual ~BlockMasterClientService_getUsedBytes_args() throw();

  bool operator == (const BlockMasterClientService_getUsedBytes_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const BlockMasterClientService_getUsedBytes_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BlockMasterClientService_getUsedBytes_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BlockMasterClientService_getUsedBytes_pargs {
 public:


  virtual ~BlockMasterClientService_getUsedBytes_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _BlockMasterClientService_getUsedBytes_result__isset {
  _BlockMasterClientService_getUsedBytes_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _BlockMasterClientService_getUsedBytes_result__isset;

class BlockMasterClientService_getUsedBytes_result {
 public:

  BlockMasterClientService_getUsedBytes_result(const BlockMasterClientService_getUsedBytes_result&);
  BlockMasterClientService_getUsedBytes_result& operator=(const BlockMasterClientService_getUsedBytes_result&);
  BlockMasterClientService_getUsedBytes_result() : success(0) {
  }

  virtual ~BlockMasterClientService_getUsedBytes_result() throw();
  int64_t success;
   ::AlluxioTException e;

  _BlockMasterClientService_getUsedBytes_result__isset __isset;

  void __set_success(const int64_t val);

  void __set_e(const  ::AlluxioTException& val);

  bool operator == (const BlockMasterClientService_getUsedBytes_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const BlockMasterClientService_getUsedBytes_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BlockMasterClientService_getUsedBytes_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _BlockMasterClientService_getUsedBytes_presult__isset {
  _BlockMasterClientService_getUsedBytes_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _BlockMasterClientService_getUsedBytes_presult__isset;

class BlockMasterClientService_getUsedBytes_presult {
 public:


  virtual ~BlockMasterClientService_getUsedBytes_presult() throw();
  int64_t* success;
   ::AlluxioTException e;

  _BlockMasterClientService_getUsedBytes_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class BlockMasterClientService_getWorkerInfoList_args {
 public:

  BlockMasterClientService_getWorkerInfoList_args(const BlockMasterClientService_getWorkerInfoList_args&);
  BlockMasterClientService_getWorkerInfoList_args& operator=(const BlockMasterClientService_getWorkerInfoList_args&);
  BlockMasterClientService_getWorkerInfoList_args() {
  }

  virtual ~BlockMasterClientService_getWorkerInfoList_args() throw();

  bool operator == (const BlockMasterClientService_getWorkerInfoList_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const BlockMasterClientService_getWorkerInfoList_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BlockMasterClientService_getWorkerInfoList_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BlockMasterClientService_getWorkerInfoList_pargs {
 public:


  virtual ~BlockMasterClientService_getWorkerInfoList_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _BlockMasterClientService_getWorkerInfoList_result__isset {
  _BlockMasterClientService_getWorkerInfoList_result__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _BlockMasterClientService_getWorkerInfoList_result__isset;

class BlockMasterClientService_getWorkerInfoList_result {
 public:

  BlockMasterClientService_getWorkerInfoList_result(const BlockMasterClientService_getWorkerInfoList_result&);
  BlockMasterClientService_getWorkerInfoList_result& operator=(const BlockMasterClientService_getWorkerInfoList_result&);
  BlockMasterClientService_getWorkerInfoList_result() {
  }

  virtual ~BlockMasterClientService_getWorkerInfoList_result() throw();
  std::vector<WorkerInfo>  success;
   ::AlluxioTException e;

  _BlockMasterClientService_getWorkerInfoList_result__isset __isset;

  void __set_success(const std::vector<WorkerInfo> & val);

  void __set_e(const  ::AlluxioTException& val);

  bool operator == (const BlockMasterClientService_getWorkerInfoList_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const BlockMasterClientService_getWorkerInfoList_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BlockMasterClientService_getWorkerInfoList_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _BlockMasterClientService_getWorkerInfoList_presult__isset {
  _BlockMasterClientService_getWorkerInfoList_presult__isset() : success(false), e(false) {}
  bool success :1;
  bool e :1;
} _BlockMasterClientService_getWorkerInfoList_presult__isset;

class BlockMasterClientService_getWorkerInfoList_presult {
 public:


  virtual ~BlockMasterClientService_getWorkerInfoList_presult() throw();
  std::vector<WorkerInfo> * success;
   ::AlluxioTException e;

  _BlockMasterClientService_getWorkerInfoList_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class BlockMasterClientServiceClient : virtual public BlockMasterClientServiceIf, public  ::AlluxioServiceClient {
 public:
  BlockMasterClientServiceClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
     ::AlluxioServiceClient(prot, prot) {}
  BlockMasterClientServiceClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :     ::AlluxioServiceClient(iprot, oprot) {}
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void getBlockInfo( ::BlockInfo& _return, const int64_t blockId);
  void send_getBlockInfo(const int64_t blockId);
  void recv_getBlockInfo( ::BlockInfo& _return);
  int64_t getCapacityBytes();
  void send_getCapacityBytes();
  int64_t recv_getCapacityBytes();
  int64_t getUsedBytes();
  void send_getUsedBytes();
  int64_t recv_getUsedBytes();
  void getWorkerInfoList(std::vector<WorkerInfo> & _return);
  void send_getWorkerInfoList();
  void recv_getWorkerInfoList(std::vector<WorkerInfo> & _return);
};

class BlockMasterClientServiceProcessor : public  ::AlluxioServiceProcessor {
 protected:
  boost::shared_ptr<BlockMasterClientServiceIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (BlockMasterClientServiceProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_getBlockInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getCapacityBytes(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getUsedBytes(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getWorkerInfoList(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  BlockMasterClientServiceProcessor(boost::shared_ptr<BlockMasterClientServiceIf> iface) :
     ::AlluxioServiceProcessor(iface),
    iface_(iface) {
    processMap_["getBlockInfo"] = &BlockMasterClientServiceProcessor::process_getBlockInfo;
    processMap_["getCapacityBytes"] = &BlockMasterClientServiceProcessor::process_getCapacityBytes;
    processMap_["getUsedBytes"] = &BlockMasterClientServiceProcessor::process_getUsedBytes;
    processMap_["getWorkerInfoList"] = &BlockMasterClientServiceProcessor::process_getWorkerInfoList;
  }

  virtual ~BlockMasterClientServiceProcessor() {}
};

class BlockMasterClientServiceProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  BlockMasterClientServiceProcessorFactory(const ::boost::shared_ptr< BlockMasterClientServiceIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< BlockMasterClientServiceIfFactory > handlerFactory_;
};

class BlockMasterClientServiceMultiface : virtual public BlockMasterClientServiceIf, public  ::AlluxioServiceMultiface {
 public:
  BlockMasterClientServiceMultiface(std::vector<boost::shared_ptr<BlockMasterClientServiceIf> >& ifaces) : ifaces_(ifaces) {
    std::vector<boost::shared_ptr<BlockMasterClientServiceIf> >::iterator iter;
    for (iter = ifaces.begin(); iter != ifaces.end(); ++iter) {
       ::AlluxioServiceMultiface::add(*iter);
    }
  }
  virtual ~BlockMasterClientServiceMultiface() {}
 protected:
  std::vector<boost::shared_ptr<BlockMasterClientServiceIf> > ifaces_;
  BlockMasterClientServiceMultiface() {}
  void add(boost::shared_ptr<BlockMasterClientServiceIf> iface) {
     ::AlluxioServiceMultiface::add(iface);
    ifaces_.push_back(iface);
  }
 public:
  void getBlockInfo( ::BlockInfo& _return, const int64_t blockId) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getBlockInfo(_return, blockId);
    }
    ifaces_[i]->getBlockInfo(_return, blockId);
    return;
  }

  int64_t getCapacityBytes() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getCapacityBytes();
    }
    return ifaces_[i]->getCapacityBytes();
  }

  int64_t getUsedBytes() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getUsedBytes();
    }
    return ifaces_[i]->getUsedBytes();
  }

  void getWorkerInfoList(std::vector<WorkerInfo> & _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getWorkerInfoList(_return);
    }
    ifaces_[i]->getWorkerInfoList(_return);
    return;
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class BlockMasterClientServiceConcurrentClient : virtual public BlockMasterClientServiceIf, public  ::AlluxioServiceConcurrentClient {
 public:
  BlockMasterClientServiceConcurrentClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
     ::AlluxioServiceConcurrentClient(prot, prot) {}
  BlockMasterClientServiceConcurrentClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :     ::AlluxioServiceConcurrentClient(iprot, oprot) {}
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void getBlockInfo( ::BlockInfo& _return, const int64_t blockId);
  int32_t send_getBlockInfo(const int64_t blockId);
  void recv_getBlockInfo( ::BlockInfo& _return, const int32_t seqid);
  int64_t getCapacityBytes();
  int32_t send_getCapacityBytes();
  int64_t recv_getCapacityBytes(const int32_t seqid);
  int64_t getUsedBytes();
  int32_t send_getUsedBytes();
  int64_t recv_getUsedBytes(const int32_t seqid);
  void getWorkerInfoList(std::vector<WorkerInfo> & _return);
  int32_t send_getWorkerInfoList();
  void recv_getWorkerInfoList(std::vector<WorkerInfo> & _return, const int32_t seqid);
};

#ifdef _WIN32
  #pragma warning( pop )
#endif



#endif
