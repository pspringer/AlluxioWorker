// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "BlockWorkerClientService.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

class BlockWorkerClientServiceHandler : virtual public BlockWorkerClientServiceIf {
 public:
  BlockWorkerClientServiceHandler() {
    // Your initialization goes here
  }

  /**
   * Accesses a block given the block id.
   * 
   * @param blockId the id of the block being accessed
   */
  void accessBlock(const int64_t blockId) {
    // Your implementation goes here
    printf("accessBlock\n");
  }

  /**
   * Used to cache a block into Alluxio space, worker will move the temporary block file from session
   * folder to data folder, and update the space usage information related. then update the block
   * information to master.
   * 
   * @param sessionId the id of the current session
   * 
   * @param blockId the id of the block being accessed
   */
  void cacheBlock(const int64_t sessionId, const int64_t blockId) {
    // Your implementation goes here
    printf("cacheBlock\n");
  }

  /**
   * Used to cancel a block which is being written. worker will delete the temporary block file and
   * the location and space information related, then reclaim space allocated to the block.
   * 
   * @param sessionId the id of the current session
   * 
   * @param blockId the id of the block being accessed
   */
  void cancelBlock(const int64_t sessionId, const int64_t blockId) {
    // Your implementation goes here
    printf("cancelBlock\n");
  }

  /**
   * Locks the file in Alluxio's space while the session is reading it. If lock succeeds, the path of
   * the block's file along with the internal lock id of locked block will be returned. If the block's file
   * is not found, FileDoesNotExistException will be thrown.
   * 
   * @param blockId the id of the block being accessed
   * 
   * @param sessionId the id of the current session
   */
  void lockBlock(LockBlockResult& _return, const int64_t blockId, const int64_t sessionId) {
    // Your implementation goes here
    printf("lockBlock\n");
  }

  /**
   * Used to promote block on under storage layer to top storage layer when there are more than one
   * storage layers in Alluxio's space. return true if the block is successfully promoted, false
   * otherwise.
   * 
   * @param blockId the id of the block being accessed
   */
  bool promoteBlock(const int64_t blockId) {
    // Your implementation goes here
    printf("promoteBlock\n");
  }

  /**
   * Used to remove a block from an Alluxio worker.
   * 
   * 
   * @param blockId the id of the block being removed
   */
  void removeBlock(const int64_t blockId) {
    // Your implementation goes here
    printf("removeBlock\n");
  }

  /**
   * Used to allocate location and space for a new coming block, worker will choose the appropriate
   * storage directory which fits the initial block size by some allocation strategy, and the
   * temporary file path of the block file will be returned. if there is no enough space on Alluxio
   * storage OutOfSpaceException will be thrown, if the file is already being written by the session,
   * FileAlreadyExistsException will be thrown.
   * 
   * @param sessionId the id of the current session
   * 
   * @param blockId the id of the block being accessed
   * 
   * @param initialBytes initial number of bytes requested
   * 
   * @param writeTier the target tier to write to
   */
  void requestBlockLocation(std::string& _return, const int64_t sessionId, const int64_t blockId, const int64_t initialBytes, const int32_t writeTier) {
    // Your implementation goes here
    printf("requestBlockLocation\n");
  }

  /**
   * Used to request space for some block file. return true if the worker successfully allocates
   * space for the block on block's location, false if there is no enough space, if there is no
   * information of the block on worker, FileDoesNotExistException will be thrown.
   * 
   * @param sessionId the id of the current session
   * 
   * @param blockId the id of the block being accessed
   * 
   * @param requestBytes the number of bytes requested
   */
  bool requestSpace(const int64_t sessionId, const int64_t blockId, const int64_t requestBytes) {
    // Your implementation goes here
    printf("requestSpace\n");
  }

  /**
   * Local session send heartbeat to local worker to keep its temporary folder.
   * 
   * @param sessionId the id of the current session
   * 
   * @param metrics deprecated since 1.3.0 and will be removed in 2.0
   */
  void sessionHeartbeat(const int64_t sessionId, const std::vector<int64_t> & metrics) {
    // Your implementation goes here
    printf("sessionHeartbeat\n");
  }

  /**
   * Used to unlock a block after the block is accessed, if the block is to be removed, delete the
   * block file. return true if successfully unlock the block, return false if the block is not
   * found or failed to delete the block.
   * 
   * @param blockId the id of the block being accessed
   * 
   * @param sessionId the id of the current session
   */
  bool unlockBlock(const int64_t blockId, const int64_t sessionId) {
    // Your implementation goes here
    printf("unlockBlock\n");
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<BlockWorkerClientServiceHandler> handler(new BlockWorkerClientServiceHandler());
  shared_ptr<TProcessor> processor(new BlockWorkerClientServiceProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

