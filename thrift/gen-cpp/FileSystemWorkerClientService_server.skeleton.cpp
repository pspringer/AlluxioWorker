// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "FileSystemWorkerClientService.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

class FileSystemWorkerClientServiceHandler : virtual public FileSystemWorkerClientServiceIf {
 public:
  FileSystemWorkerClientServiceHandler() {
    // Your initialization goes here
  }

  /**
   * Cancels a file which has not been completed in the under file system.
   * 
   * @param sessionId the id of the current session
   * 
   * @param tempUfsFileId the worker specific file id of the ufs file
   * 
   * @param options the options for canceling the file
   */
  void cancelUfsFile(const int64_t sessionId, const int64_t tempUfsFileId, const CancelUfsFileTOptions& options) {
    // Your implementation goes here
    printf("cancelUfsFile\n");
  }

  /**
   * Closes a file in the under file system which was previously opened for reading.
   * 
   * 
   * @param sessionId the id of the current session
   * 
   * @param tempUfsFileId the worker specific file id of the ufs file
   * 
   * @param options the options for closing the file
   */
  void closeUfsFile(const int64_t sessionId, const int64_t tempUfsFileId, const CloseUfsFileTOptions& options) {
    // Your implementation goes here
    printf("closeUfsFile\n");
  }

  /**
   * Completes a file in the under file system.
   * 
   * @param sessionId the id of the current session
   * 
   * @param tempUfsFileId the worker specific file id of the ufs file
   * 
   * @param options the options for completing the file
   */
  int64_t completeUfsFile(const int64_t sessionId, const int64_t tempUfsFileId, const CompleteUfsFileTOptions& options) {
    // Your implementation goes here
    printf("completeUfsFile\n");
  }

  /**
   * Creates a file in the under file system.
   * 
   * @param sessionId the id of the current session
   * 
   * @param ufsPath the path of the file in the ufs
   * 
   * @param options the options for creating the file
   */
  int64_t createUfsFile(const int64_t sessionId, const std::string& ufsPath, const CreateUfsFileTOptions& options) {
    // Your implementation goes here
    printf("createUfsFile\n");
  }

  /**
   * Opens an existing file in the under file system for reading.
   * 
   * @param sessionId the id of the current session
   * 
   * @param ufsPath the path of the file in the ufs
   * 
   * @param options the options for opening the file
   */
  int64_t openUfsFile(const int64_t sessionId, const std::string& ufsPath, const OpenUfsFileTOptions& options) {
    // Your implementation goes here
    printf("openUfsFile\n");
  }

  /**
   * Local session send heartbeat to local worker to keep its state.
   * 
   * @param sessionId the id of the current session
   * 
   * @param metrics the client metrics. deprecated since 1.3.0 and will be removed in 2.0
   */
  void sessionHeartbeat(const int64_t sessionId, const std::vector<int64_t> & metrics) {
    // Your implementation goes here
    printf("sessionHeartbeat\n");
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<FileSystemWorkerClientServiceHandler> handler(new FileSystemWorkerClientServiceHandler());
  shared_ptr<TProcessor> processor(new FileSystemWorkerClientServiceProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

